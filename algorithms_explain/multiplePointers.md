# Multiple Pointers(다중 포인터)

## 투 포인터(다중 포인터)

**두 개 또는 그 이상의 포인터를 두고 값들을 특정 조건에 따라 움직이게 하여 문제를 해결하는 알고리즘 패턴**을 말한다.

## 첫번째 예제

첫번째 예제는 시작과 마지막에 두 개의 포인터를 두고 문제의 조건에 따라 움직이며 문제를 해결한다. 문제를 살펴보자.

```javascript
// 예제
/* 정렬된 배열 내에 합이 0이 되는 한쌍의 값을 찾는 함수 sumZero를 만들어라.
   > 제안사항
		 - input 값은 오름차순으로 정렬된 배열이다.
     - 하나의 쌍도 존재하지 않는경우 undefined를 반환한다.
		 - 결과값은 배열로 반환한다.
*/
// input
sumZero([-3,-2,-1,0,1,2,3]) // => [-3,3]
sumZero([-2,-,1,3]) // => undefined
sumZero([1,2,3]) // => undefined
```

간단한 접근 방법으로는 2번의 `for` 문을 통해서 순환을 돌리는 방법이다.

배열의 첫번째 수를 두번째 수부터 마지막 수까지 비교하는 것을 시작으로 마지막에서 두번째 숫자와 마지막 수를 대조해보는 것으로 접근하는 방법이다.

```javascript
function sumZero(arr) {
	for(let i = 0; i < arr.length; ++i){
		for(let j = i +1; j < arr.length; ++j){
			if(arr[i] + arr[j] === 0) {
				return [arr[i],arr[j]];
			}
		}
	}
}
```

위와 같은 풀이법으로 봤을 때의 공간 복잡도와 시간 복잡도는 어떻게 될까?

- 시간 복잡도 : 두 번의 반복문(`O(n)`)을 통해 연산됨. ⇒   `O(n^2)`
- 공간 복잡도 :  `O(1)`

위와 같은 시간 복잡도를 갖는 코드가 아닌 더욱 효율적인 문제에 대한 접근 방법을 생각해보자.

### 접근방법

배열이 오름차순. 즉, 낮은 수부터 높은 수로 정렬되어 있다는 것을 이용한 방법이다.

1. 제일 작은 수와 높은 수를 더해 결과가 양수인지 음수인지 0인지를 확인한다.
2. 양수일 경우 높은 숫자에서 한단계를 낮춘 숫자로 포인터(위치)를 변경한다.
3. 음수일 경우 낮은 숫자에서 한단계를 높인 숫자로 포인터(위치)를 변경한다.
4. 0 일 경우에는 해당하는 두 수를 배열에 담아 반환하며, 
5. 4.가 될 때 까지 2,3을 낮은 숫자를 담은 포인터가 높은 숫자를 담은 포인터를 넘지 않을 때 까지 반복한다.

코드를 통해 이해해보자.

```javascript
function sumZero(arr) {
	// 정렬된 배열 arr의 위치(index) 값을 저장한다.
	let left = 0;
	let right = arr.length -1;

	while (left < right) { // 5.
		let sum = arr[left]+arr[right]; // 1.

		if(sum===0) { //4.
			return [ arr[left], arr[right]];
		} else if(sum > 0) { //2.
			right--;
		} else { //3.
			left++;
		}
	}
}
```

이렇게 되면 이중 `for` 문을 사용하여 시간 복잡도가 `O(n^2)` 에서 while문 하나로 `O(n)` 의 시간 복잡도를 갖게 된다.

## 두번째 예제

두번째 예제는 좌측에 두개의 포인터를 두고 이동하며 결과값을 반환하는 방법이다.

```javascript
// 예제
/* 정렬된 배열 내에서 수의 개수를 구하는 함수 countUniqueValues를 만들어라.
   > 제안사항
		 - input 배열 값은 오름차순으로 정렬된 배열이다.
     - 빈 배열의 경우 0을 반환한다.
		 - 음수 또한 배열내에 존재할 수 있다.
*/
// input
countUniqueValues([1,1,1,1,2]) // 1,2 => 2
countUniqueValues([1,2,2,3,4,4,4,7,7,12,12,13]) // 1,2,3,4,7,12,13 => 7
countUniqueValues([]) // => 0
```

이를 다중 포인터를 이용하여 해결해보자.

### 접근방법

변수 설정

- p1 : pointer 1 의 의미로 앞에 위치한 `index`를 가리킴.
- p2 : pointer 2 의 의미로 상대적으로 뒤에 위치한 `index`를 가리킴.
- count : 결과값이 될 변수.

1. 배열의 첫번째 수와 두번째 수를 비교하여 같은 경우와 다른 경우로 나눈다.
2. 같은 경우에는 두번째수의 위치값을 올려 다시 첫번째 수와 비교한다.
    
    만약, `count`의 초기값을 0으로 해두면, 배열의 값이 딱 두 수 뿐인데 값이 같은 경우에 1이어야할 `count` 가 `0` 인 상태로 리턴 되므로 `count`의 초기값은 `1` 이다.
    
3. 이 때문에 따로 `arr` 이 빈 배열 또는 값이 하나뿐인 배열일 경우에 대해 `0` 을 리턴할 수 있도록 한다.
4. 다른 경우에는 두수가 다르므로 `count` 값을 하나 올리고 `arr[p1]` 에 대입하여 `p2` 의 위치 값을 올린 후 다음 반복에 이전 `arr[p2]` 위치값이 바뀐 `arr[p2]` 가 비교될 수 있도록 한다.
5. 위와 같은 반복을 `p2` 의 위치값이 총 배열의 마지막 `index` 까지 도달할 수 있도록 한다.

```javascript
function countUniqueValues(arr) {
    let p1 = 0;
    let p2 = 1;

    let count=1;

    if(arr.length <= 1) return 0;

    while(p2 <= arr.length-1){
        if(arr[p1] === arr[p2]){
            p2++;
        } else{
            arr[p1]=arr[p2];
            p2++;
            count++;
        }
    }
    return count;
}
```

### 강사의 풀이

기본적인 원리는 같지만 강사의 마지막 결과값 반환을 보면 `p1+1` 인 것을 알 수 있다.

이는 `p1` 자체가 `arr[p2]` 를 받아오면서 중첩값들을 제거하고 순수 다른 값들만을 저장하면서 증가하는 `index` 값이므로 `arr[0]` 부터 `arr[p1]` 까지의 개수가 결과값과 같다는 것을 의미한다.