# 버블 정렬(Bubble Sort)

## 버블 정렬

---

버블 정렬은 서로 인접한 두 원소를 검사하여 정렬하는 알고리즘이다.

오름차순 정렬의 경우, 정렬하고자 하는 값의 길이만큼 한번 순회를 거쳐 가장 큰 수를 마지막으로 밀어내고

![버블정렬](https://user-images.githubusercontent.com/79589584/158199435-58d799e8-8f2e-4dcd-8dd6-c19070e18822.png)


이후 그다음으로 큰수를 밀어내는 과정을 반복하여 정렬한다.

버블 정렬은 교환이 이루어 지기 때문에 JavaScript에서 변수 내의 값을 교환하는 방법은 다음과 같다.

### 값의 교환

ES5에서 값을 교환하기 위해서는 임시로 값을 저장할 변수를 만들어야했다.

```jsx
// ES5
function swap(arr, idx1, idx2) {
	let temp = arr[idx1];
	arr[idx1] = arr[idx2];
	arr[idx2] = temp;
}
```

하지만 ES6에서는 더욱 간단하게 교환이 가능해졌다.

```jsx
// ES6
function swap(arr, idx1, idx2) {
	[arr[idx1], arr[idx2]] = [arr[idx2], arr[idx1]];
}
```

## 버블 정렬의 의사코드

---

1. 버블 정렬하는 반복 횟수를 설정하는 외부 순환 반복문 `i` 를 만든다.
2. 한 사이클 당 일어나는 정렬 횟수는 버블 정렬하는 반복횟수의 `arr.length-i-1` 만큼이 이루어진다. ( `i` 는 `0` 부터 시작한다.)
즉, 길이 `5` 의 배열은 첫 순환이 `4` 번 정렬과 교환이 이루어지고, 그 다음은 정렬된 마지막 수를 제외한 `3` 번. 그 다음은 `2` 번... 으로 이루어진다.
3. 내부 반복문의 `j` 는 현재 배열의 `index` 를 의미하며, 두 수의 비교는 `j` 와 `j+1` 과 이루어 진다.
4. 반복되어 정렬이 완료되면 배열을 반환한다.

```jsx
function bubbleSort(arr) {
		// 1. 버블 정렬의 반복 사이클 횟수를 결정하는 외부 순환 반복문
    for(let i = 0; i < arr.length; i++){
				// 2. 한 사이클 당 버블하는 횟수를 결정하는 내부 순환 반복문
				// 3. 총 버블 횟수는 0 부터 arr.length-i-1
        for(let j = 0; j < arr.length-i-1; j++){
						// 3. arr[j] 와 arr[j+1]의 비교와 버블을 통한 교환
            if (arr[j] > arr[j+1]) {
                /* ES5
                let temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
                */

                /* ES6 */
                [ arr[j], arr[j+1] ] = [ arr[j+1], arr[j] ];
            }
        }
    }
		// 4. 정렬 완료 후 배열 반환
    return arr;
}

bubbleSort([37, 45, 29, 8]); // [8, 29, 37, 45]
```

그런데 여기서 거의 정렬되어있는 배열을 인수로 넘긴다고 가정하면, 어떤 일이 일어날까?

`[8, 1, 2, 3, 4]` 의 배열을 인수로 주고 몇번의 `for` 문이 동작하는지 확인해 보자.

`내부 for 문`과 `외부 for 문`이 동작하였을 때는 출력이 되게끔 각 `for 문` 의 마지막에 `console` 을 띄우도록 하였다.

![버블정렬의 비효율적 작동](https://user-images.githubusercontent.com/79589584/158199336-c8cf5910-717d-41b1-8e8f-268558a2e87d.JPG)


형광 색깔로 칠해진 곳을 보면 알 듯, 이미 정렬이 완료 되었음에도 `외부 for문` 이 반복되어 동작되는 것을 볼 수 있다.

불필요한 코드의 동작이 없도록 `break` 문을 통해서 빠져나올 수 있도록 바꾸었다.

```jsx
function bubbleSort(arr) {
		// 두 값의 교체가 있었는지를 boolean 값을 통해 저장하는 변수
    let noSwaps;
    
    for(let i = 0; i < arr.length-1; i++){
        noSwaps = true; // 처음 기본값이 매번 true 가 되도록 설정
        
        for(let j = 0; j < arr.length-i-1; j++){
            console.log(arr, arr[j], arr[j+1])
            if (arr[j] > arr[j+1]) {
                [arr[j],arr[j+1]] = [arr[j+1],arr[j]];
                noSwaps = false; // 값의 교환이 있었을 때엔 false 가 되도록 설정
            }
            console.log("내부 for문")
        }
        if(noSwaps) break; // 값의 교환이 없었을 경우 더 이상의 교환 없이 정렬이 완료됐으므로 외부 for문 종료
        console.log("외부 for문")
    }
    return arr;
}
```

설명을 하자면 다음과 같다. `noSwaps` 는 두 값의 비교 후 값의 교환이 있었는지를 확인하는 변수이다.

밑의 콘솔창을 보면 첫번째 사이클로 정렬이 완료되었음을 확인할 수 있다.

![버블정렬의 비효율적 작동 해결](https://user-images.githubusercontent.com/79589584/158199148-e2040f1f-d9c6-488c-bc7a-2e90adad7418.JPG)

그런데 `내부 for문` 이 한번 더 동작한 것을 알 수 있다. 이는 첫번째 사이클을 통해 정렬이 되었지만 컴퓨터는 이를 알 수 없다. 

또한 이미 `noSwaps` 가 `8` 로 인해 값의 교환이 있었기 때문에 다음 사이클이 한번 더 진행이 되는 것이고 이 과정에서 더이상의 값의 교환이 있는지를 확인하게 된다.

값의 교환이 두번째 사이클에서 일어나지 않았고 이는 정렬이 되어 교환할 값이 없음을 의미해 `외부 for문` 또한 종료하게 된다.

## Big O

---

위에서 코드를 통해 `버블 정렬` 이 `이중 for문` 을 통해 정렬된다는 것을 우리는 알고 있다.

위키백과에 따른 버블 정렬의 `Big O`를 보면 아래와 같다.

### 시간 복잡도

- 평균, 최악 : `O(n^2)`
- 최선 : `O(n)`

  <span style="color:green"> * 정렬이 거의 되어 있거나 다 되어있는 배열을 인수로 받는 경우 선형 시간에 가깝다.</span>

### 공간 복잡도

- 최악 : `O(1)`

때문에 이러한 버블 정렬은 그리 효육적인 방법은 아니라서 일반적으로 사용되지는 않는다고한다.

## 장•단점

---

### 장점

1. 알고리즘이 단순하다.
2. 정렬하고자 하는 배열 내에서 값의 교환이 이루어져, 정렬을 위한 다른 메모리 공간을 필요로 하지 않는 **제자리 정렬(in-place sorting)** 이다.
3. 동일한 값의 키 값이 변하지 않는 **안전 정렬(Stable sort)** 이다.

### 단점

1. 평균 시간 복잡도가 `O(n^2)` 으로 비효율적이다.
2. 값들이 정렬될 위치로 가기 위한 교환 연산이 많이 일어난다.