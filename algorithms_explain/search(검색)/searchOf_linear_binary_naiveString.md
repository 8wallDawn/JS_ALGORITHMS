# 검색 알고리즘(선형, 이진 검색과 Naive String Search)

검색 알고리즘은 배열에 대한 선형 검색과 정렬된 배열에 대한 이진 검색이 있다.

위의 접근 방식이 장점만 지닌 것은 아니다.

특정 정보를 담은 배열 `arr` 이 있다고 가정해보자.

이 `arr` 배열 내에는 이미 수 많은 데이터들이 이미 들어있고 그 중 특정한 하나의 데이터를 찾고자 한다.

가장 찾기 간단한 방법은 처음부터 하나하나 다 확인해보는 방법이 있을 것이다.

이러한 접근 방식을 **선형 검색(Linear Search)** 라고 한다.

그럼 순서대로 하나하나 찾는 방법이 좋은 방법이라고 이야기 할 수 있을까?

그렇지만은 않다.

만약 알파벳, 숫자, 한글의 순서에 맞게 정렬되어 있는 데이터라고 가정한다면, 특정한 범위 내에서 찾는 것이 좋을 것이다.

정렬된 배열 내에서 중간 지점을 잡고 검색하는 것을 반복하는 것이 바로 **이진 검색(Binary Search)** 이다.   

## 선형 검색(Linear Search)

---

배열에 대해서 **순차적으로 모든 요소를 확인**하며 대조하는 검색 방법으로 **정렬되지 않은 데이터에서 할 수 있는 최선의 검색 방법**이다.

이러한 선행 검색의 예로 JavaScript에서 `배열` 을 다루는 검색 메소드가 있다.

- `Array.indexOf()`
    - 배열에서 지정된 요소를 찾을 수 있는 `첫 번째 인덱스`를 반환하고 존재하지 않으면 `-1`을 반환.
- `Array.includes()`
    - 배열이 특정 요소를 포함하고 있는지 판별.
- `Array.find()`
    - 주어진 판별 함수를 `만족하는 첫 번째 요소의 값`을 반환하고 그런 요소가 없다면 `[undefined](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/undefined)`를 반환.
- `Array.findIndex()`
    - 주어진 판별 함수를 만족하는 배열의 `첫 번째 요소에 대한 인덱스`를 반환합니다. 만족하는 요소가 없으면 `-1`을 반환.

위의 메소드는 모두 하나씩 모든 요소를 확인한다. 위의 메소드와 같이 선형 검색의 원리를 의사코드로 작성해보면 아래와 같다.

### 선형 검색의 원리

1. 배열과 특정 값을 인수로 받는다.
2. `배열` 의 값들을 순회하며, 찾고자 하는 특정 값과 일치하는지를 확인한다.
3. 일치한다면 `인덱스` 또는 `값`, `true` 를 반환한다.
4. 일치하는 값이 없다면 `-1` 또는 `false` 값을 반환한다.

이러한 선형 검색의 의사코드를  `for` 문을 이용하여 작성한 코드이다.

```jsx
function linearSearch(arr, val) {
  for (let i = 0; i < arr.length; i++) {
    if (arr[i] === val) return i;
  }
  return -1;
}
```

### 선형 검색의 Big O

즉, 선형 검색은 `for` 문과 같이 Big O 가 `O(n)` 이라는 것을 예상할 수 있다.

물론 찾고자하는 `val` 의 값이 `arr` 의 첫번째 요소였다면 단번에 끝날 작업이 되겠지만 배열의 길이가 길어질 수록, 찾고자 하는 값이 배열 내에서 뒤에 있는 요소일 수록 `Big O` 는 `O(n)`에 가깝게 증가한다.

## 이진 검색(Binary Search)

---

이진 검색은 선형 검색 보다 더욱 빠른 검색으로 주어진 조건에 대해 검색의 폭을 줄여나감으로서 시간적 단축에 대한 이점이 생기나 주의할 점으로는 정렬된 배열이어야 한다는 것이다.

### 이진 검색의 원리

1. 정렬된 배열 또는 값을 인수로 받는다.
2. 정렬된 배열 또는 값의 시작과 끝을 포인터로 잡는다.
3. 두 포인터를 통해 중간값을 설정한다.
4. 정렬된 배열 또는 값의 중간 값이 찾는 값과 동일한지 확인하고 아닌 경우 반복수행한다.
    1. 찾는 값과 동일하다면 해당 `index`를 반환한다.
    2. 찾는 값이 중간 값이 작다면, 오른쪽 포인터를 중간 값의 `index-1` 지점으로 이동한다.
    3. 찾는 값이 중간 값보다 크다면, 왼쪽 포인터를 중간 값의 `index+1` 지점으로 이동한다.\
5. 찾는 값이 없다면 `-1` 또는 `false`를 반환한다.

이를 차근히 코드로 바꾸어 보자.

시작과 끝을 포인터로 잡기 때문에 멀티 포인터의 투 포인터 알고리즘을 참고하면 더욱 쉽게 접근이 가능하다.

```jsx
function binarySearch(arr,num){
	// 2. 배열의 시작과 끝을 포인터로 잡는다.
  let lowerIdx = 0;
  let higherIdx = arr.length - 1;
  
	// 4. 중간 값과 찾는 num이 같을 때 까지를 반복하는 while문을 만든다.
  while(lowerIdx <= higherIdx ) {
		// 3. 두 포인터를 통해 중간값을 설정한다.
    let middleIdx = Math.floor( (lowerIdx + higherIdx) / 2 );
    
		// a. 찾는 값과 동일하다면 해당 index를 반환한다.
    if(arr[middleIdx] === num) return middleIdx;

		// b. 찾는 값이 중간 값보다 작다면, 오른쪽 포인터를 중간값의 -1 로 이동한다.
    else if(arr[middleIdx] > num) {
        higherIdx= middleIdx -1;
    }

		// c. 찾는 값이 중간 값보다 크면, 왼쪽 포인터를 중간값의 +1 로 이동한다.
    else lowerIdx = middleIdx +1;
  }
	// 5. 찾는 값이 없으면 -1을 반환한다.
  return -1;
}
```

### 이진 검색(Binary Search)의 Big O

이진 검색의 원리는 주어진 값들의 길이를 계속해서 반으로 나누어 찾고자 하는 값의 대소 관계를 통해 범위를 반으로 축소하는 방법을 반복하고 있다.

예를 들어 배열의 길이가 `8` 인 `[1,2,3,4,5,6,7,8]` 에서 `7`을 찾고자 한다면,

1. 배열을 반으로 나누어 `[5,6,7,8]` 로 범위를 축소.
2. 한번 더 나우어 `[7,8]` 로 축소.

하여 찾아 길이가 `8`인 배열에서의 특정 값을 찾는 최대 단계는 **2단계**이다.

길이가 `16` 개인 경우에는 최대 **4단계**가 되고 `32` 의 경우 최대 **5단계**에 걸쳐진다.

이를 통해 Big O 가 `O(log n)` 임을 알 수 있다.

## 나이브 문자열 검색(Naive String Search)

---

나이브 문자열 검색은 긴 문자열 내에 짧은 문자열을 매치 시키는 패턴 검색이다.

예를 들어 `the butter betty botter bought was a bit bitter and made her batter bitter` 라는 문자열에서 `bitter` 라는 단어를 검색하기 위한 방법이다.

### 나이브 문자열 검색의 원리

1. 긴 문자열을 한글자씩 반복문을 통해 순회하며,
2. 긴 문자열을 순회하는 반복문 내에 내부 반복문으로 짧은 문자열을 만들어 문자를 대조 한다.
    1. 일치하는 경우, 내부 반복문 순회를 이어간다.
        1. 모두 일치할 경우, 일치한 항목의 수를 증가하거나 일치 유무 값 등의 결과를 반환한다.
    2. 일치하지 않는 경우 내부 반복문을 빠져나온다.

이를 코드로 변환해보자.

```jsx
function (longerStr, shortStr) {
	// 일치 횟수를 저장하는 변수 생성
	let count = 0;

	// 1. 긴 문자열을 한글자씩 반복문을 통해 순회
	for(let i = 0; i<longerStr.length; ++i;) {
		// 2. 짧은 문자열을 한글자씩 반복문을 통해 순회
		for(let j = 0; j<shortStr.length; ++i;) {
			// 2.b. 일치하지 않는 경우 다음 긴문자열과 대조하기 위해 break
			if (longerStr[i+j] !== shorStr[j]) break; 
			// 2.a.i 짧은 문자열을 모두 순회화며 대조되어 일치한 경우 count + 1
			if (j === shortStr.length -1) count++;
		}
	}
	// 결과 반환
	return count;
}
```

위의 코드에서 유심히 보아야 하는 부분이 바로 `shortStr` 반복문 내, 첫번째 `if` 문의 조건식이다.

`longerStr[i+j]` 와 `shortStr[j]` 를 비교하고 있다.

그 이유는 내부 반복문에서는 `j` 값만이 증가되고 있다. 즉, `longerStr`과 `shortStr` 의 첫번째 글자가 같다라고 가정하고 두번째 글자를 비교한다 하였을 때 두 문자열 모두 다음 문자열로 이동해야 한다는 것이다.

| longerStr : xarmy | x | a | r | m | y |
| --- | --- | --- | --- | --- | --- |
| i | 0 | 1 | 2 | 3 | 4 |
| shortStr : army |  | a | r | m | y |
| j |  | 0 | 1 | 2 | 3 |

`longerStr` 이 `'xarmy'` , `shortStr` 이 `'army'` 라고 하였을 때 동일비교가 될 때를 표로 작성했다.

`i` 의 값이 `'a'` 에 도달 했을 때, `shortStr` 은 동일하게 되어 반복문을 이어나갈 것이라 `i`의 값은 고정이 된다.

그럼 남은 뒤의 `'r', 'm', 'y'` 는 모두 `j` 값이 증가할 때 함께 증가하므로 `i+j` 가 되는 것이다.